# Communication Bus Console Application

In 3rd year we had a team project in which we implemented a Communication Bus Console Application.

First project where we used TFS for Agile software development process.
---
Writing user stories, having Scrum meetings with our teaching assistant (sprint
planning, sprint review and retrospective).

Communication Bus
---
Prilikom pokretanja programa, neophodno je prethodno instalirati bazu Microsoft SQL Server. Kako bi se uspesno konektovali sa bazom podataka potrebno je kreirati bazu pod nazivom “RES” Kreiranje tabela I popunjavanje atributa u bazi potrebno je izvrsiti putem skripti koje su ostavljene u posebnom folderu pod nazivom “Skripte”. Nakon sto se uspesno kreiraju sve tabele u bazi,sa datim atributima, pokrece se aplikacija u nekoj od verzija Visual studia. Iz opcije Server Explorer, nakon kreirane baze, potrebno je uraditi connect sa bazom,nakon cega je aplikacija spremna za pokretanje.

Communication bus je aplikacija koja radi sa bazom podataka, I obavlja odredjene operacije koje korisnik zadaje putem komandi u glavnoj konzoli. Sa glavne konzole pratite uputstva za operacije koje zelite izvrsiti nad bazom. Konkretno, ova aplikacija podrzava sledece operacije: GET,PUT,POST,PATCH I DELETE. Inicijalni zahtev koji mora da zadovolji uslov aplikacije mora bit napisan u sledecem primer formatu: GET /resurs/id , gde id predstavlja jedan od atributa odgovarajuce tabele,u ovom slucaju tabele resurs. Sve operacije podrzavaju unosenje dodatnih atributa ,ukoliko zelite filtrirati odredjene podatke na nacin koji vama odgovara. U sledecim primerima bice opisane naredbe sa odgovarajucim filterima koje je potrebno zadati na ispravan nacin,kako bi se na ispravan nacin manipulisalo podacima u bazi. Za pribavljanje nekog podatka u tabeli vrsi operacija GET . Potrebno je ispravno napisati zahtev u formatu GET /resurs/id gde se pored zadatog atributa mogu navesti I dodatni atributi query I fields. Atribut query zapocinje oznakom “?” ,dok atribut fields zapocinje oznakom “|”. Ukoliko se ne navede ispravno query ili filed filter sa odgovarajucom oznakom ,zahtev ce biti odbije. U sledecim primerima bice opisani nacini na koji se moze vrsiti filtriranje zeljenih tabela. Pod filterom query podrazumeva se da se navode imena ili vrednosti kolona u tabeli, na sledeci nacin: GET /resurs/id?name=’primer’&type=broj –primer zahteva sa oba atributa query dela GET /resurs/id?name=’primer’ –primer zahteva sa jednim atributom GET /resurs/id?type=broj

Pod filterom fields podrazumeva da se navodi pod kojim kolonama da se filtrira zahtev,pri cemu je neophodno filter fields navesti zajedno sa filterom query. Vazno je napomenuti da se filed deo od query dela obavezno razdvaja “|” .Primer zahteva sa field filterom : GET /resurs/id?name=’primer’&type=0|name GET /resurs/id?name=’primer’&type=0|name;type

Sve navedne operacije za primer sa tabelom resurs,pisu se u istom formatu I za ostale komande PUT,POST,PATCH I DELETE. Za tabelu “tip” jedini atribut u tabeli je naziv(“name”) cija je uloga da vrati naziv tipa resursa glavne tabele resurs, pa je primer zahteva sledeci: GET /tip/id?name=’primer’ Ostale operacije PUT,PATCH,POST I DELETE pisu se na isti nacin kao I GET. Za tabelu “tipveze” atribut je takodje naziv(“name”),cija je uloga da vrati naziv tipa, gde se operacije GET,PUT,PATCH,POST I DELETE konstruisu na isti nacin kao I za tabelu “tip”. Vazno je napomenuti da prethodne dve tabele nemaju mogucnost filtriranja sa query I fields filterom,te ce takav zahtev biti odbijen. Za tabelu “veza” cija je uloga da vrati id prvog I id drugog resursa kao I id tipveze , zahtevi se konstruisu na sledeci nacin: GET /veza/id?idV=1&id1=2&id2=3&type=7

Gde idV oznacava id tipa veze, id1 –id prvog , id2-id drugog resursa. Prethodni primer napisan je sa query filterom,gde se pod query filterom podrazumevaju polja idV,id1,id2. Primer zahteva sa field filterom je sledeci: GET /veza/id|idV;id1;id2 Ostali zahtevi POST,PATCH,PUT I DELETE pisu se na isti nacin kao I GET zahtev.

Implementacija: Kako bi se bolje razumela upotreba I funkcionisanje aplikacije ,u nastavku ce biti opisani glavni delovi implementacije Communication Bus aplikacije. Interakcija korisnika I aplikacije zapocinje komandovanjem kroz glavni prikaz konzole, u kojoj korisnik vrsi neke od operacija GET,PUT,POST,PATCH I DELETE. Prihvtanje zahteva od strane klijenta obavlja WebClient klasa koja u prvim koracima vrsi validaciju napisanog zahteva kako bi dalje obradila informacije za prosledjivanje ostalim komponentama. WebClient komponenta prima zahtev od korisnika u formi http zahteva,ciji je zadatak da tako primljenu poruku konvertuje u json format,konkretno implementaciji ovaj zadatak obavlja metoda “ConvertToJSON”. Ovakav zahtev prosledjuje se dalje narednoj komponenti JSONToXMLAdapter, ciji je zadatak da formatirani json zahtev obradi I konvertuje u xml zahtev kako bi se pravilno prosledio sledecoj komponenti. Konverziju zahteva u xml obavlja metoda “ConvertToXML”. Tako pretvorena poruka salje se sledecoj komponenti CommunicationBus-u ,ciji je zadatak da prosledi primljenu poruku narednoj komponenti, bez potrebnih konverzija ili izvrsavanja nekih operacija. Ovu operaciju vrsi metoda “Forward()”. Prosledjenu poruku od CommunicationBus-a prima komponenta XMLToDBAdapter, cija je uloga da xml poruku konvertuje u odgovarajuci upit kako bi se pravilno izvrsile operacije nad bazom podatka. Metoda “ConvertToDB” vrsi ovu konverziju. Sledeca komponenta koja prima konvertovanu poruku je Repository komponenta koja ima zadataka da izvrsava odgovarajuce komande nad bazom. Sve operacije nad bazom vrse se u ovoj komponenti koja je povezana sa bazom. Glavna klasa za povezivanje sa bazom u Repository komponenti je klasa RepositoryKlasa. Nakom sto se zahtev izvrsi nad bazom,korisniku se vraca poruka istom putanjom ,prolazeci kroz sve komponente u nazad. Metode koje vrse obrnute konverzije nalaze se u istim komponentama.

U prilogu dokumenatacije, dostavljene su slike dijagrama kako bi se bolje razumela sama komunikacija izmedju komponenti I njihovog povezivanja.
